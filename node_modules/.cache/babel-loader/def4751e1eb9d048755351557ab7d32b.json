{"ast":null,"code":"import { LngLat, Point } from 'mapbox-gl';\nexport var anchors = ['center', 'top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'];\nexport var anchorTranslates = {\n  center: 'translate(-50%, -50%)',\n  top: 'translate(-50%, 0)',\n  left: 'translate(0, -50%)',\n  right: 'translate(-100%, -50%)',\n  bottom: 'translate(-50%, -100%)',\n  'top-left': 'translate(0, 0)',\n  'top-right': 'translate(-100%, 0)',\n  'bottom-left': 'translate(0, -100%)',\n  'bottom-right': 'translate(-100%, -100%)'\n};\nvar defaultElement = {\n  offsetWidth: 0,\n  offsetHeight: 0\n};\nvar defaultPoint = [0, 0];\nvar projectCoordinates = function (map, coordinates) {\n  return map.project(LngLat.convert(coordinates));\n};\nvar calculateAnchor = function (map, offsets, position, _a) {\n  var _b = _a === void 0 ? defaultElement : _a,\n    offsetHeight = _b.offsetHeight,\n    offsetWidth = _b.offsetWidth;\n  var anchor = [];\n  if (position.y + offsets.bottom.y - offsetHeight < 0) {\n    anchor = [anchors[1]];\n  } else if (position.y + offsets.top.y + offsetHeight > map.transform.height) {\n    anchor = [anchors[2]];\n  }\n  if (position.x < offsetWidth / 2) {\n    anchor.push(anchors[3]);\n  } else if (position.x > map.transform.width - offsetWidth / 2) {\n    anchor.push(anchors[4]);\n  }\n  if (anchor.length === 0) {\n    return anchors[2];\n  }\n  return anchor.join('-');\n};\nvar normalizedOffsets = function (offset) {\n  if (!offset) {\n    return normalizedOffsets(new Point(0, 0));\n  }\n  if (typeof offset === 'number') {\n    var cornerOffset = Math.round(Math.sqrt(0.5 * Math.pow(offset, 2)));\n    return {\n      center: new Point(offset, offset),\n      top: new Point(0, offset),\n      bottom: new Point(0, -offset),\n      left: new Point(offset, 0),\n      right: new Point(-offset, 0),\n      'top-left': new Point(cornerOffset, cornerOffset),\n      'top-right': new Point(-cornerOffset, cornerOffset),\n      'bottom-left': new Point(cornerOffset, -cornerOffset),\n      'bottom-right': new Point(-cornerOffset, -cornerOffset)\n    };\n  }\n  if (offset instanceof Point || Array.isArray(offset)) {\n    return anchors.reduce(function (res, anchor) {\n      res[anchor] = Point.convert(offset);\n      return res;\n    }, {});\n  }\n  return anchors.reduce(function (res, anchor) {\n    res[anchor] = Point.convert(offset[anchor] || defaultPoint);\n    return res;\n  }, {});\n};\nexport var overlayState = function (props, map, container) {\n  var position = projectCoordinates(map, props.coordinates);\n  var offsets = normalizedOffsets(props.offset);\n  var anchor = props.anchor || calculateAnchor(map, offsets, position, container);\n  return {\n    anchor: anchor,\n    position: position,\n    offset: offsets[anchor]\n  };\n};\nvar moveTranslate = function (point) {\n  return point ? \"translate(\" + point.x.toFixed(0) + \"px, \" + point.y.toFixed(0) + \"px)\" : '';\n};\nexport var overlayTransform = function (_a) {\n  var anchor = _a.anchor,\n    position = _a.position,\n    offset = _a.offset;\n  var res = [];\n  if (position) {\n    res.push(moveTranslate(position));\n  }\n  if (offset && offset.x !== undefined && offset.y !== undefined) {\n    res.push(moveTranslate(offset));\n  }\n  if (anchor) {\n    res.push(anchorTranslates[anchor]);\n  }\n  return res;\n};","map":{"version":3,"sources":["../../src/util/overlays.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { LngLat, Point } from 'mapbox-gl';\nexport var anchors = [\n    'center',\n    'top',\n    'bottom',\n    'left',\n    'right',\n    'top-left',\n    'top-right',\n    'bottom-left',\n    'bottom-right'\n];\nexport var anchorTranslates = {\n    center: 'translate(-50%, -50%)',\n    top: 'translate(-50%, 0)',\n    left: 'translate(0, -50%)',\n    right: 'translate(-100%, -50%)',\n    bottom: 'translate(-50%, -100%)',\n    'top-left': 'translate(0, 0)',\n    'top-right': 'translate(-100%, 0)',\n    'bottom-left': 'translate(0, -100%)',\n    'bottom-right': 'translate(-100%, -100%)'\n};\nvar defaultElement = { offsetWidth: 0, offsetHeight: 0 };\nvar defaultPoint = [0, 0];\nvar projectCoordinates = function (map, coordinates) {\n    return map.project(LngLat.convert(coordinates));\n};\nvar calculateAnchor = function (map, offsets, position, _a) {\n    var _b = _a === void 0 ? defaultElement : _a, offsetHeight = _b.offsetHeight, offsetWidth = _b.offsetWidth;\n    var anchor = [];\n    if (position.y + offsets.bottom.y - offsetHeight < 0) {\n        anchor = [anchors[1]];\n    }\n    else if (position.y + offsets.top.y + offsetHeight >\n        map.transform.height) {\n        anchor = [anchors[2]];\n    }\n    if (position.x < offsetWidth / 2) {\n        anchor.push(anchors[3]);\n    }\n    else if (position.x > map.transform.width - offsetWidth / 2) {\n        anchor.push(anchors[4]);\n    }\n    if (anchor.length === 0) {\n        return anchors[2];\n    }\n    return anchor.join('-');\n};\nvar normalizedOffsets = function (offset) {\n    if (!offset) {\n        return normalizedOffsets(new Point(0, 0));\n    }\n    if (typeof offset === 'number') {\n        var cornerOffset = Math.round(Math.sqrt(0.5 * Math.pow(offset, 2)));\n        return {\n            center: new Point(offset, offset),\n            top: new Point(0, offset),\n            bottom: new Point(0, -offset),\n            left: new Point(offset, 0),\n            right: new Point(-offset, 0),\n            'top-left': new Point(cornerOffset, cornerOffset),\n            'top-right': new Point(-cornerOffset, cornerOffset),\n            'bottom-left': new Point(cornerOffset, -cornerOffset),\n            'bottom-right': new Point(-cornerOffset, -cornerOffset)\n        };\n    }\n    if (offset instanceof Point || Array.isArray(offset)) {\n        return anchors.reduce(function (res, anchor) {\n            res[anchor] = Point.convert(offset);\n            return res;\n        }, {});\n    }\n    return anchors.reduce(function (res, anchor) {\n        res[anchor] = Point.convert(offset[anchor] || defaultPoint);\n        return res;\n    }, {});\n};\nexport var overlayState = function (props, map, container) {\n    var position = projectCoordinates(map, props.coordinates);\n    var offsets = normalizedOffsets(props.offset);\n    var anchor = props.anchor || calculateAnchor(map, offsets, position, container);\n    return {\n        anchor: anchor,\n        position: position,\n        offset: offsets[anchor]\n    };\n};\nvar moveTranslate = function (point) {\n    return point ? \"translate(\" + point.x.toFixed(0) + \"px, \" + point.y.toFixed(0) + \"px)\" : '';\n};\nexport var overlayTransform = function (_a) {\n    var anchor = _a.anchor, position = _a.position, offset = _a.offset;\n    var res = [];\n    if (position) {\n        res.push(moveTranslate(position));\n    }\n    if (offset && offset.x !== undefined && offset.y !== undefined) {\n        res.push(moveTranslate(offset));\n    }\n    if (anchor) {\n        res.push(anchorTranslates[anchor]);\n    }\n    return res;\n};\n//# sourceMappingURL=overlays.js.map"]},"metadata":{},"sourceType":"module"}