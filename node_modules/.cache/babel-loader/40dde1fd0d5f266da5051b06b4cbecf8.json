{"ast":null,"code":"import KDBush from 'kdbush';\nconst defaultOptions = {\n  minZoom: 0,\n  // min zoom to generate clusters on\n  maxZoom: 16,\n  // max zoom level to cluster the points on\n  minPoints: 2,\n  // minimum points to form a cluster\n  radius: 40,\n  // cluster radius in pixels\n  extent: 512,\n  // tile extent (radius is calculated relative to it)\n  nodeSize: 64,\n  // size of the KD-tree leaf node, affects performance\n  log: false,\n  // whether to log timing info\n\n  // whether to generate numeric ids for input features (in vector tiles)\n  generateId: false,\n  // a reduce function for calculating custom cluster properties\n  reduce: null,\n  // (accumulated, props) => { accumulated.sum += props.sum; }\n\n  // properties to use for individual points when running the reducer\n  map: props => props // props => ({sum: props.my_value})\n};\nexport default class Supercluster {\n  constructor(options) {\n    this.options = extend(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n  }\n  load(points) {\n    const {\n      log,\n      minZoom,\n      maxZoom,\n      nodeSize\n    } = this.options;\n    if (log) console.time('total time');\n    const timerId = `prepare ${points.length} points`;\n    if (log) console.time(timerId);\n    this.points = points;\n\n    // generate a cluster object for each point and index input points into a KD-tree\n    let clusters = [];\n    for (let i = 0; i < points.length; i++) {\n      if (!points[i].geometry) continue;\n      clusters.push(createPointCluster(points[i], i));\n    }\n    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n    if (log) console.timeEnd(timerId);\n\n    // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n    // results in a cluster hierarchy across zoom levels\n    for (let z = maxZoom; z >= minZoom; z--) {\n      const now = +Date.now();\n\n      // create a new set of clusters for the zoom and index them with a KD-tree\n      clusters = this._cluster(clusters, z);\n      this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n      if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n    }\n    if (log) console.timeEnd('total time');\n    return this;\n  }\n  getClusters(bbox, zoom) {\n    let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n    const minLat = Math.max(-90, Math.min(90, bbox[1]));\n    let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n    const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n    if (bbox[2] - bbox[0] >= 360) {\n      minLng = -180;\n      maxLng = 180;\n    } else if (minLng > maxLng) {\n      const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n      const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n      return easternHem.concat(westernHem);\n    }\n    const tree = this.trees[this._limitZoom(zoom)];\n    const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n    const clusters = [];\n    for (const id of ids) {\n      const c = tree.points[id];\n      clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n    }\n    return clusters;\n  }\n  getChildren(clusterId) {\n    const originId = this._getOriginId(clusterId);\n    const originZoom = this._getOriginZoom(clusterId);\n    const errorMsg = 'No cluster with the specified id.';\n    const index = this.trees[originZoom];\n    if (!index) throw new Error(errorMsg);\n    const origin = index.points[originId];\n    if (!origin) throw new Error(errorMsg);\n    const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n    const ids = index.within(origin.x, origin.y, r);\n    const children = [];\n    for (const id of ids) {\n      const c = index.points[id];\n      if (c.parentId === clusterId) {\n        children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n      }\n    }\n    if (children.length === 0) throw new Error(errorMsg);\n    return children;\n  }\n  getLeaves(clusterId, limit, offset) {\n    limit = limit || 10;\n    offset = offset || 0;\n    const leaves = [];\n    this._appendLeaves(leaves, clusterId, limit, offset, 0);\n    return leaves;\n  }\n  getTile(z, x, y) {\n    const tree = this.trees[this._limitZoom(z)];\n    const z2 = Math.pow(2, z);\n    const {\n      extent,\n      radius\n    } = this.options;\n    const p = radius / extent;\n    const top = (y - p) / z2;\n    const bottom = (y + 1 + p) / z2;\n    const tile = {\n      features: []\n    };\n    this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.points, x, y, z2, tile);\n    if (x === 0) {\n      this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.points, z2, y, z2, tile);\n    }\n    if (x === z2 - 1) {\n      this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.points, -1, y, z2, tile);\n    }\n    return tile.features.length ? tile : null;\n  }\n  getClusterExpansionZoom(clusterId) {\n    let expansionZoom = this._getOriginZoom(clusterId) - 1;\n    while (expansionZoom <= this.options.maxZoom) {\n      const children = this.getChildren(clusterId);\n      expansionZoom++;\n      if (children.length !== 1) break;\n      clusterId = children[0].properties.cluster_id;\n    }\n    return expansionZoom;\n  }\n  _appendLeaves(result, clusterId, limit, offset, skipped) {\n    const children = this.getChildren(clusterId);\n    for (const child of children) {\n      const props = child.properties;\n      if (props && props.cluster) {\n        if (skipped + props.point_count <= offset) {\n          // skip the whole cluster\n          skipped += props.point_count;\n        } else {\n          // enter the cluster\n          skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n          // exit the cluster\n        }\n      } else if (skipped < offset) {\n        // skip a single point\n        skipped++;\n      } else {\n        // add a single point\n        result.push(child);\n      }\n      if (result.length === limit) break;\n    }\n    return skipped;\n  }\n  _addTileFeatures(ids, points, x, y, z2, tile) {\n    for (const i of ids) {\n      const c = points[i];\n      const isCluster = c.numPoints;\n      const f = {\n        type: 1,\n        geometry: [[Math.round(this.options.extent * (c.x * z2 - x)), Math.round(this.options.extent * (c.y * z2 - y))]],\n        tags: isCluster ? getClusterProperties(c) : this.points[c.index].properties\n      };\n\n      // assign id\n      let id;\n      if (isCluster) {\n        id = c.id;\n      } else if (this.options.generateId) {\n        // optionally generate id\n        id = c.index;\n      } else if (this.points[c.index].id) {\n        // keep id if already assigned\n        id = this.points[c.index].id;\n      }\n      if (id !== undefined) f.id = id;\n      tile.features.push(f);\n    }\n  }\n  _limitZoom(z) {\n    return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n  }\n  _cluster(points, zoom) {\n    const clusters = [];\n    const {\n      radius,\n      extent,\n      reduce,\n      minPoints\n    } = this.options;\n    const r = radius / (extent * Math.pow(2, zoom));\n\n    // loop through each point\n    for (let i = 0; i < points.length; i++) {\n      const p = points[i];\n      // if we've already visited the point at this zoom level, skip it\n      if (p.zoom <= zoom) continue;\n      p.zoom = zoom;\n\n      // find all nearby points\n      const tree = this.trees[zoom + 1];\n      const neighborIds = tree.within(p.x, p.y, r);\n      const numPointsOrigin = p.numPoints || 1;\n      let numPoints = numPointsOrigin;\n\n      // count the number of points in a potential cluster\n      for (const neighborId of neighborIds) {\n        const b = tree.points[neighborId];\n        // filter out neighbors that are already processed\n        if (b.zoom > zoom) numPoints += b.numPoints || 1;\n      }\n      if (numPoints >= minPoints) {\n        // enough points to form a cluster\n        let wx = p.x * numPointsOrigin;\n        let wy = p.y * numPointsOrigin;\n        let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n        // encode both zoom and point index on which the cluster originated -- offset by total length of features\n        const id = (i << 5) + (zoom + 1) + this.points.length;\n        for (const neighborId of neighborIds) {\n          const b = tree.points[neighborId];\n          if (b.zoom <= zoom) continue;\n          b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n          const numPoints2 = b.numPoints || 1;\n          wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n          wy += b.y * numPoints2;\n          b.parentId = id;\n          if (reduce) {\n            if (!clusterProperties) clusterProperties = this._map(p, true);\n            reduce(clusterProperties, this._map(b));\n          }\n        }\n        p.parentId = id;\n        clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n      } else {\n        // left points as unclustered\n        clusters.push(p);\n        if (numPoints > 1) {\n          for (const neighborId of neighborIds) {\n            const b = tree.points[neighborId];\n            if (b.zoom <= zoom) continue;\n            b.zoom = zoom;\n            clusters.push(b);\n          }\n        }\n      }\n    }\n    return clusters;\n  }\n\n  // get index of the point from which the cluster originated\n  _getOriginId(clusterId) {\n    return clusterId - this.points.length >> 5;\n  }\n\n  // get zoom of the point from which the cluster originated\n  _getOriginZoom(clusterId) {\n    return (clusterId - this.points.length) % 32;\n  }\n  _map(point, clone) {\n    if (point.numPoints) {\n      return clone ? extend({}, point.properties) : point.properties;\n    }\n    const original = this.points[point.index].properties;\n    const result = this.options.map(original);\n    return clone && result === original ? extend({}, result) : result;\n  }\n}\nfunction createCluster(x, y, id, numPoints, properties) {\n  return {\n    x,\n    // weighted cluster center\n    y,\n    zoom: Infinity,\n    // the last zoom the cluster was processed at\n    id,\n    // encodes index of the first child of the cluster and its zoom level\n    parentId: -1,\n    // parent cluster id\n    numPoints,\n    properties\n  };\n}\nfunction createPointCluster(p, id) {\n  const [x, y] = p.geometry.coordinates;\n  return {\n    x: lngX(x),\n    // projected point coordinates\n    y: latY(y),\n    zoom: Infinity,\n    // the last zoom the point was processed at\n    index: id,\n    // index of the source feature in the original input array,\n    parentId: -1 // parent cluster id\n  };\n}\nfunction getClusterJSON(cluster) {\n  return {\n    type: 'Feature',\n    id: cluster.id,\n    properties: getClusterProperties(cluster),\n    geometry: {\n      type: 'Point',\n      coordinates: [xLng(cluster.x), yLat(cluster.y)]\n    }\n  };\n}\nfunction getClusterProperties(cluster) {\n  const count = cluster.numPoints;\n  const abbrev = count >= 10000 ? `${Math.round(count / 1000)}k` : count >= 1000 ? `${Math.round(count / 100) / 10}k` : count;\n  return extend(extend({}, cluster.properties), {\n    cluster: true,\n    cluster_id: cluster.id,\n    point_count: count,\n    point_count_abbreviated: abbrev\n  });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n  return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n  const sin = Math.sin(lat * Math.PI / 180);\n  const y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n  return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n  return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n  const y2 = (180 - y * 360) * Math.PI / 180;\n  return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\nfunction extend(dest, src) {\n  for (const id in src) dest[id] = src[id];\n  return dest;\n}\nfunction getX(p) {\n  return p.x;\n}\nfunction getY(p) {\n  return p.y;\n}","map":{"version":3,"names":["KDBush","defaultOptions","minZoom","maxZoom","minPoints","radius","extent","nodeSize","log","generateId","reduce","map","props","Supercluster","constructor","options","extend","Object","create","trees","Array","load","points","console","time","timerId","length","clusters","i","geometry","push","createPointCluster","getX","getY","Float32Array","timeEnd","z","now","Date","_cluster","getClusters","bbox","zoom","minLng","minLat","Math","max","min","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","ids","range","lngX","latY","id","c","numPoints","getClusterJSON","index","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","origin","r","pow","within","x","y","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","p","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","result","skipped","child","cluster","point_count","isCluster","f","type","round","tags","getClusterProperties","undefined","neighborIds","numPointsOrigin","neighborId","b","wx","wy","clusterProperties","_map","numPoints2","createCluster","point","clone","original","Infinity","coordinates","xLng","yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","exp","dest","src"],"sources":["/Users/george/Developer/rentalsite/node_modules/supercluster/index.js"],"sourcesContent":["\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (c.x * z2 - x)),\n                    Math.round(this.options.extent * (c.y * z2 - y))\n                ]],\n                tags: isCluster ? getClusterProperties(c) : this.points[c.index].properties\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            if (numPoints >= minPoints) { // enough points to form a cluster\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x, // weighted cluster center\n        y,\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: lngX(x), // projected point coordinates\n        y: latY(y),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}